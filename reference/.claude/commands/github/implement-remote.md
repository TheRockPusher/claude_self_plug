---
description: Execute plan autonomously with incremental commits and remote push
allowed-tools:
  - Read
  - Glob
  - Grep
  - Write
  - Edit
  - Bash
  - TodoWrite
  - Task
  - WebSearch
  - WebFetch
argument-hint: <path-to-plan>
model: opus
---

# Implement Remote: Autonomous GitHub Implementation Workflow

## Plan to Execute

Read plan file: `$ARGUMENTS`

---

## Mission

Execute implementation plan **autonomously** with incremental commits, continuous
validation, and automatic pushing to remote branch for async collaboration.

**Core Principle**: Work independently, make reasonable decisions, commit frequently,
validate continuously, document everything.

**Workflow**: Verify Branch → Load → Implement → Validate → Commit → Push → Repeat

**Autonomy Philosophy**: Fix errors without user input when solution is clear.
Only escalate when blocked after 3 fix attempts or when security implications exist.

---

<critical_decisions>

## Phase 0: Environment Verification

**Critical checks before starting:**

### 1. Git State Verification

```bash
git status
git branch -vv
git remote -v
```

**Verify**:

- [ ] On a feature branch (not main/master)
- [ ] Branch tracks remote origin
- [ ] Working directory clean or changes are planned

**If on main/master**:

- ERROR: Cannot implement on main branch
- This command requires feature branch created by `/github:plan-remote`
- Run `/github:plan-remote` first or manually create feature branch

**If working directory dirty**:

- Document uncommitted changes
- Continue (will commit all changes together after validation)

### 2. Plan File Validation

```bash
# Verify plan file exists
test -f "$ARGUMENTS" && echo "Plan found" || echo "ERROR: Plan not found"
```

**Read the ENTIRE plan file:**

- Extract feature name and metadata
- Verify these sections exist:
  - CONTEXT REFERENCES (Mandatory Reading)
  - STEP-BY-STEP TASKS
  - VALIDATION COMMANDS
  - NOTES & AUTONOMOUS DECISIONS (if generated by plan-remote)

**If critical sections missing**:

- Document what's missing in execution notes
- Infer reasonable approach from what's available
- Continue with caution (note assumptions in final commit message)

### 3. Autonomous Mode Configuration

**Set execution parameters:**

```text
Max Fix Iterations: 3 per validation level
Commit Strategy: After each phase passes validation
Push Strategy: After each successful commit
Error Escalation: Only after 3 failed fix attempts
User Questions: Only for security or breaking changes
```

</critical_decisions>

---

<autonomous_protocols>

## Autonomous Fix Protocol

**Apply at any validation checkpoint when errors occur.**

### 3-Iteration Progressive Depth Analysis

Attempt up to 3 iterations with increasing depth before escalating:

| Iteration      | Focus                      | Actions                                                                                                  | Re-run & Decision            |
|----------------|----------------------------|----------------------------------------------------------------------------------------------------------|------------------------------|
| **1. Surface** | Syntax & Style | Fix linting errors, type hints, imports, formatting, obvious test failures | PASS → Continue \| FAIL → Iteration 2 |
| **2. Logic** | Edge Cases & Requirements | Analyse error messages, check off-by-one errors, verify edge cases, review plan alignment | PASS → Continue \| FAIL → Iteration 3 |
| **3. Deep** | Integration & Patterns | Re-read mandatory files, compare with plan line-by-line, check integration, verify dependencies | PASS → Continue \| FAIL → Escalate |

### Escalation Criteria

Escalate after 3 failed iterations OR immediately if:

- ❌ Security implications uncertain
- ❌ Breaking changes to public APIs
- ❌ External dependency/environment issues

### Escalation Format

```markdown
BLOCKER DETECTED:

Validation: {command}
Iterations: 3
Last error: {error-output}

Analysis:
- {What was tried}
- {Why it didn't work}
- {Suspected root cause}

Recommendation:
- {Suggested fix} OR {Mark as blocking issue for PR}
```

</autonomous_protocols>

---

## Phase 1: Context Loading

**Read ALL files listed in "Mandatory Reading" section before implementation.**

### For each file reference

1. **Read specified line ranges**

   ```bash
   # Example: path/to/file.py:15-45
   Read(file_path, offset=14, limit=30)
   ```

2. **Extract patterns**
   - Naming conventions
   - Import statements
   - Error handling approach
   - Logging patterns
   - Type annotations style

3. **Document patterns**
   - Store in working notes
   - Reference during implementation
   - Ensure consistency

**If mandatory files don't exist**:

- Document the issue
- Search for similar patterns elsewhere in codebase
- Use framework best practices as fallback
- Note deviation in commit message

---

## Phase 2: TodoWrite Setup

**Populate TodoWrite from plan's "STEP-BY-STEP TASKS" section:**

### Extract and structure tasks

```text
Plan structure:
### CREATE src/services/auth.py
### UPDATE src/routes/api.py
### ADD tests/test_auth.py

TodoWrite structure:
1. Create src/services/auth.py
2. Update src/routes/api.py
3. Add tests/test_auth.py
4. Phase 1 validation checkpoint
5. Commit Phase 1 changes
6. {Continue for all phases...}
7. Run full validation suite
8. Final commit and push
9. Create PR suggestion
```

**Add validation checkpoints**:

- After each implementation phase
- Before each commit
- Before final push

Mark first task as `in_progress` before starting.

---

## Phase 3: Incremental Implementation

**For EACH implementation phase (Foundation, Core, Integration, Testing):**

### A. Execute Phase Tasks

**For each task in phase:**

1. **Load context**
   - Re-read pattern references from plan
   - Read existing files if modifying
   - Review related code for consistency

2. **Implement**
   - Follow plan specifications exactly
   - Mirror patterns from mandatory reading
   - Maintain codebase consistency
   - Use reasonable defaults for ambiguities

3. **Syntax check**
   - Read the file back
   - Check for obvious errors
   - Verify imports resolve
   - Mark task `completed` in TodoWrite

### B. Phase Validation

**Run phase-specific validation (if specified in plan):**

```bash
# Example: After Foundation phase
ruff check src/services/  # Lint new files
mypy src/services/        # Type check
```

**Validation loop (max 3 iterations):**

1. Run validation command: `command || echo "Exit code: $?"`
2. Check result: ✅ PASS → Continue | ❌ FAIL → Apply Autonomous Fix Protocol
3. **Apply Autonomous Fix Protocol** (see above)
4. After 3 fails: Document blocker, continue to next phase (retry in full validation)

### C. Incremental Commit

**After phase validation passes:**

1. **Stage changes**

   ```bash
   git add {files-changed-in-phase}
   ```

2. **Create descriptive commit**

   ```bash
   git commit -m "{type}: {emoji} {phase-description}

   Implemented:
   - {Task 1 summary}
   - {Task 2 summary}
   - {Task 3 summary}

   Validation:
   - {validation-command-1}: PASSED
   - {validation-command-2}: PASSED

   Part of: {feature-name}
   Plan: .agents/plans/{plan-file}.md"
   ```

3. **Push to remote**

   ```bash
   git push
   ```

4. **Verify push**

   ```bash
   git status
   ```

**Commit Types**:

- `feat` - New functionality
- `fix` - Bug fixes
- `refactor` - Code restructure
- `test` - Test additions
- `docs` - Documentation

---

## Phase 4: Full Validation - MANDATORY ITERATION

**After all implementation phases complete, run FULL validation suite:**

### Execute ALL validation levels from plan

```bash
# Level 1: Lint/format
{project-specific lint command}

# Level 2: Type check
{project-specific type check command}

# Level 3: Unit tests
{project-specific test command}

# Level 4: Integration tests
{project-specific integration test command}

# Level 5: Manual validation
{Document manual steps completed}
```

### Validation Iteration Loop

**For EACH validation level:**

1. **Execute command**
   - Run exactly as specified in plan
   - Capture full output (stdout + stderr)
   - Record exit code

2. **Analyse result**
   - ✅ **Exit code 0**: Mark PASSED, continue to next level
   - ❌ **Non-zero exit**: Apply Autonomous Fix Protocol

3. **Apply Autonomous Fix Protocol** (see above) with 3-iteration progressive depth
   - Iteration 1: Surface-level fixes (syntax, style, imports)
   - Iteration 2: Logic-level fixes (edge cases, plan alignment)
   - Iteration 3: Deep analysis (patterns, integration, dependencies)
   - After 3 fails: Use escalation format and document as blocker

### Validation Success Criteria

**All levels must show**:

- [ ] Exit code 0
- [ ] No errors in output
- [ ] No warnings (or acknowledged as acceptable)
- [ ] Manual steps documented as completed

**If any level fails after 3 iterations**:

- Document in BLOCKERS section
- Continue to completion
- Mark PR as "Needs Review - Has Blockers"

---

## Phase 5: Documentation Updates

**Check if user-facing changes require documentation updates:**

### Automatic detection

- **New commands/features**: Update README.md and CLAUDE.md
- **API changes**: Update API documentation
- **Configuration changes**: Update setup documentation
- **Breaking changes**: Update migration guide

### Update strategy

1. **Read existing documentation**

   ```bash
   Read("README.md")
   Read("CLAUDE.md")
   ```

2. **Identify sections to update**
   - Match patterns in existing docs
   - Add new sections if needed
   - Maintain formatting consistency

3. **Apply updates**
   - Use Edit tool for precise changes
   - Follow existing documentation style
   - Keep British English spelling

4. **Validate documentation**

   ```bash
   npx markdownlint-cli {updated-files}
   ```

**If internal-only changes**:

- Skip documentation phase
- Note "No user-facing changes" in commit

---

## Phase 6: Final Commit & Push

**After all validations pass and docs updated:**

### 1. Stage all remaining changes

```bash
git add .
```

### 2. Create comprehensive final commit

```bash
git commit -m "{type}: {emoji} complete {feature-name}

Summary:
{2-3 sentence description of what was implemented}

Implementation Details:
- {Key component 1}
- {Key component 2}
- {Key component 3}

Testing:
- Unit tests: {number} added, all passing
- Integration tests: {status}
- Edge cases covered: {list}

Validation Results:
✅ Level 1 (Lint/Format): PASSED
✅ Level 2 (Type Safety): PASSED
✅ Level 3 (Unit Tests): PASSED
✅ Level 4 (Integration): PASSED / N/A
✅ Level 5 (Manual): COMPLETED

Files Changed:
- Created: {list new files}
- Modified: {list modified files}
- Tests: {list test files}

Documentation:
- {README.md updates} / No user-facing changes

Plan: .agents/plans/{plan-file}.md
Autonomous: {Yes/No}
Blockers: {None / See PR description}"
```

### 3. Push to remote

```bash
git push
```

### 4. Verify push success

```bash
git status
git log -1 --stat
```

---

## Phase 7: PR Preparation

**Prepare for PR creation:**

### Generate PR suggestion

```markdown
## Pull Request Ready

**Branch**: feature/{branch-name}
**Commits**: {number} commits pushed
**Status**: {Ready for Review / Needs Review - Has Blockers}

### To Create PR:

**Using GitHub CLI**:
\`\`\`bash
gh pr create --title "{feature-name}" --body "$(cat <<'EOF'
## Summary
{2-3 sentence summary}

## Changes
- {Change 1}
- {Change 2}
- {Change 3}

## Testing
- [x] Unit tests passing
- [x] Integration tests passing
- [x] Manual validation completed

## Validation Results
✅ All validation levels passed

## Documentation
- [x] README updated / No changes needed
- [x] CLAUDE.md updated / No changes needed

## Notes
{Any important notes for reviewers}

## Blockers
{None / List blockers}

---
Closes #{issue-number}
Related to: .agents/plans/{plan-file}.md
EOF
)"
\`\`\`

**Using GitHub Web**:
1. Visit: https://github.com/{org}/{repo}/compare/main...feature/{branch-name}
2. Click "Create Pull Request"
3. Use title: "{feature-name}"
4. Copy PR body from above

**Recommended Reviewers**: {Based on affected files}
```

---

## Phase 8: Completion Report

**Generate comprehensive execution report:**

### Summary

**Feature**: {Feature name}
**Status**: ✅ COMPLETED / ⚠️ COMPLETED WITH BLOCKERS / ❌ BLOCKED

### Implementation Metrics

- **Total Tasks**: {number}
- **Files Created**: {number}
- **Files Modified**: {number}
- **Test Files**: {number}
- **Total Commits**: {number} (including incremental)
- **Validation Iterations**: {number}

### Validation Results

```text
✅ Level 1 (Lint/Format): {command} - PASSED
✅ Level 2 (Type Safety): {command} - PASSED
✅ Level 3 (Unit Tests): {command} - PASSED ({X} tests)
✅ Level 4 (Integration): {command} - PASSED / N/A
✅ Level 5 (Manual): {steps} - COMPLETED
```

**If any level failed**:

```text
❌ Level X ({name}): {command} - FAILED after 3 iterations
   Error: {error-message}
   Attempted fixes:
   1. {fix-1}
   2. {fix-2}
   3. {fix-3}
   Status: Documented as blocker in PR
```

### Autonomous Decisions Made

1. **Decision**: {What was decided}
   - **Context**: {Why decision was needed}
   - **Choice**: {What was chosen}
   - **Rationale**: {Why this choice}

2. {Continue for all autonomous decisions...}

### Files Changed

**Created** ({number}):

- {file-1} ({lines} lines)
- {file-2} ({lines} lines)

**Modified** ({number}):

- {file-1} (+{added}/-{removed} lines)
- {file-2} (+{added}/-{removed} lines)

**Tests** ({number}):

- {test-file-1} ({tests} tests)
- {test-file-2} ({tests} tests)

### Git History

```bash
{git log --oneline feature/{branch}...main}
```

### Documentation Updates

- README.md: {Updated / No changes}
- CLAUDE.md: {Updated / No changes}
- Other: {List any other docs updated}

### Blockers (If Any)

**None** - All validations passed, ready for review

OR

1. **Blocker**: {Description}
   - **Validation**: {Which level failed}
   - **Error**: {Error message}
   - **Attempted Fixes**: {What was tried}
   - **Recommendation**: {Suggested resolution}

### Next Steps

**Immediate**:

```bash
gh pr create --title "{feature-name}" --body "{generated-body}"
```

**Or manually**: `https://github.com/{org}/{repo}/compare/main...feature/{branch-name}`

**After PR Created**:

- Assign reviewers
- Add labels (if applicable)
- Link related issues
- Monitor CI/CD pipeline

**Branch Info**:

- Local: feature/{branch-name}
- Remote: origin/feature/{branch-name}
- Tracking: Up to date

---

## Error Handling Quick Reference

| Category            | Fix Autonomously                                   | Escalate Immediately                   |
|---------------------|----------------------------------------------------|-----------------------------------------|
| **Syntax/Style** | ✅ Linting, formatting, imports, type hints | ❌ After 3 iterations fail |
| **Logic** | ✅ Test failures (obvious), pattern mismatches | ❌ Unclear root cause after 3 attempts |
| **Security** | ❌ Never | ✅ Always (ask user first) |
| **Breaking Changes** | ❌ Never | ✅ Public API changes |
| **External** | ❌ Dependencies, environment issues | ✅ Always |

**Escalation format**: See Autonomous Fix Protocol escalation template above.

---

## Commit Message Template

**Standard commit during phases**:

```text
{type}: {emoji} {brief-description}

Implemented:
- {Task summary 1}
- {Task summary 2}

Validation: {commands} - PASSED
Part of: {feature-name}
```

**Final completion commit**:

```text
feat: ✨ complete {feature-name}

Summary:
{Full description}

Implementation Details:
{Key components}

Testing:
{Test coverage}

Validation Results:
{All 5 levels}

Files Changed:
{File list}

Plan: .agents/plans/{plan-file}.md
```

---

## Best Practices

### During Implementation

- ✅ Commit after each phase passes validation
- ✅ Push immediately after each commit
- ✅ Fix errors within 3 iterations or document
- ✅ Mirror existing codebase patterns
- ✅ Write tests before marking task complete
- ✅ Run validation after every change
- ✅ Update documentation for user-facing changes

### Avoid

- ❌ One massive commit at end
- ❌ Pushing without validation
- ❌ Skipping tests "to do later"
- ❌ Assuming without checking
- ❌ Inventing new patterns unnecessarily
- ❌ Pushing broken code
- ❌ Forgetting to document autonomous decisions

---

## Success Criteria

**Implementation is successful when**:

- [ ] All tasks from plan completed
- [ ] All 5 validation levels pass
- [ ] Incremental commits pushed to remote
- [ ] Documentation updated if needed
- [ ] PR ready with clear description
- [ ] No unresolved blockers (or blockers documented)
- [ ] Branch pushed and tracking remote
- [ ] All autonomous decisions documented

**Ready to merge when**:

- [ ] PR created and linked to plan
- [ ] All validations passing
- [ ] Documentation reviewed
- [ ] No blocking comments from reviewers

---

## Guidelines

- **Work autonomously** - Make reasonable decisions, document everything
- **Commit frequently** - After each phase, not just at end
- **Push regularly** - Enable async collaboration
- **Fix iteratively** - Try 3 times, then escalate
- **Validate continuously** - After every significant change
- **Document decisions** - Every choice made without user input
- **Update documentation** - Keep user-facing docs current
- **Prepare for review** - Make PR creation easy

ultrathink
